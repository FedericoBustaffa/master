\documentclass[12pt, a4paper]{article}

\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{mathtools, amsmath, amssymb, amsthm}
\usepackage[hidelinks]{hyperref}
\usepackage{tabularx}
\usepackage{svg}
\usepackage{caption}
\usepackage{float}
\usepackage{booktabs}

\title{Assignment 1\\Intrinsics and Auto-Vectorization}
\author{Federico Bustaffa}
\date{12/03/2025}

\begin{document}

\maketitle
\tableofcontents

\section{Introduction}

This report discuss the methodology adopted for the optimized implementations
of the \textit{softmax} function. The first one using the \textit{auto-vectorization}
provided by the compiler and the second using explicit vectorization with
\textit{intrinsics}.

Both versions were compared to each other and with the \textit{plain} naive
version provided by the teacher, mainly evaluating the execution time as the
input size varies.

\section{Methods and Implementation}

The plain version of the algorithm has been compiled with only the \verb|-O2|
flag, disabling the \textit{auto-vectorization}; mainly to see the improvement
over a non vectorized version.

For both versions, optimizations were applied incrementally by adding changes
and testing performance at each step.

\subsection{Auto-Vectorization}

To check if optimizations were applied by the compiler, it has been used the
\verb|-fopt-info-vec-missed| flag.

The first step was to use \verb|-O3| and \verb|-march=native| flags to enable
all possible optimizations the compiler can apply. At this stage, the compiler
notifies that basically every loop can't be vectorized.

To let the compiler optimize the code, the first changes were:
\begin{itemize}
	\item Add the \verb|__restricted__| qualifier to \verb|input| and
	      \verb|output| arrays, in order to avoid pointer aliasing.
	\item Split the second loop in two loops, in order to let the first line
	      not be affected by the \textit{write-after-write} dependecy that the
	      second line causes.
	\item Compute the inverse of the sum before the last loop and perform a
	      multiplication instead of a division, generally less performant than
	      the first one.
\end{itemize}
The first step of the algorithm also finds the maximum value of the given array
by looping over it. To improve this step the \textit{loop unrolling} technique
was applied by a factor of 2 and 4.

In the end the \verb|-ffast-math| flag was enabled, causing the higher
improvement but also some approximation error.

\subsection{Intrinsics}

The \textit{intrinsics} version was also compiled with some optimization flag
like \verb|-O3|, \verb|-march=native| and \verb|-mavx|, to enable the vectorized
instruction set and improve memory access.

The first major change was to find the max value of the array

\section{Comparisons}

\begin{table}[H]
	\centering
	\begin{tabular}{rrrr}
		\toprule
		Elements & Plain($\mu$s) & Unroll2($\mu$s) & Unroll4($\mu$s) \\
		\midrule
		128      & 6.0034        & 6.1522          & 5.4836          \\
		1024     & 16.0794       & 12.7019         & 10.4904         \\
		8192     & 98.5208       & 42.4009         & 36.0347         \\
		16384    & 187.9920      & 74.9148         & 67.2819         \\
		\bottomrule
	\end{tabular}
	\caption{Execution time for different factors of loop unrolling}
\end{table}

\end{document}
